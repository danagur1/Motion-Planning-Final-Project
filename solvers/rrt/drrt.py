import networkx as nx
import matplotlib.pyplot as plt

from .. import Robot, RobotDisc, RobotPolygon, RobotRod
from .. import Obstacle, ObstacleDisc, ObstaclePolygon, Scene
from .. import PathPoint, Path, PathCollection

from ..samplers import Sampler_Uniform
from ..tensor_roadmap import TensorRoadmap, build_probabilistic_roadmap
from discopygal.bindings import *
from ...geometry_utils import conversions
from ..Solver import Solver


class dRRT(Solver):
    """
    Implementation of the dRRT algorithm for multi-robot motion planning.
    This is done by generating PRMs for each robot seperatly, and then running RRT where
    we only add valid vertices and edges in the tensor roadmap generated by the tensor product
    of the individual roadmaps.

    :param num_landmarks: number of landmarks to sample in the tensor roadmap
    :type num_landmarks: :class:`int`
    :param prm_num_landmarks: number of landmarks to sample in each robot's PRM
    :type prm_num_landmarks: :class:`int`
    :param prm_k: number of nearest neighbors to connect for PRM
    :type prm_k: :class:`int`
    :param nearest_neighbors: a nearest neighbors algorithm *for the tensor roadmap*. if None then use sklearn implementation
    :type nearest_neighbors: :class:`~discopygal.solvers.nearest_neighbors.NearestNeighbors` or :class:`None`
    :param prm_nearest_neighbors: a nearest neighbors algorithm *for the PRM*. if None then use sklearn implementation
    :type prm_nearest_neighbors: :class:`~discopygal.solvers.nearest_neighbors.NearestNeighbors` or :class:`None`
    :param metric: a metric for choosing best edge, can be different then the nearest_neighbors metric!
        If None then use euclidean metric
    :type metric: :class:`~discopygal.solvers.metrics.Metric` or :class:`None`
    :param sampler: sampling algorithm/method. if None then use uniform sampling
    :type sampler: :class:`~discopygal.solvers.samplers.Sampler`

    """
    def __init__(self, num_landmarks, prm_num_landmarks, prm_k, bounding_margin_width_factor=Solver.DEFAULT_BOUNDS_MARGIN_FACTOR, nearest_neighbors=None, prm_nearest_neighbors=None, metric=None, sampler=None):
        super().__init__(bounding_margin_width_factor)
        self.num_landmarks = num_landmarks
        self.prm_num_landmarks = prm_num_landmarks
        self.prm_k = prm_k

        self.nearest_neighbors = nearest_neighbors
        self.prm_nearest_neighbors = prm_nearest_neighbors
        self.metric = metric

        self.sampler = sampler
        if self.sampler is None:
            self.sampler = Sampler_Uniform()

        self.tensor_roadmap = None

    @staticmethod
    def get_arguments():
        """
        Return a list of arguments and their description, defaults and types.
        Can be used by a GUI to generate fields dynamically.
        Should be overridded by solvers.

        :return: arguments dict
        :rtype: :class:`dict`
        """
        return {
            'num_landmarks': ('Number of Landmarks (in dRRT):',1000, int),
            'prm_num_landmarks': ('Number of Landmarks (in PRM):',2000, int),
            'prm_k': ('K for nearest neighbors:', 15, int),
            'bounding_margin_width_factor': ('Margin width factor (for bounding box):', Solver.DEFAULT_BOUNDS_MARGIN_FACTOR, FT),
        }

    @staticmethod
    def from_arguments(d):
        """
        Get a dictionary of arguments and return a solver.
        Should be overridded by solvers.

        :param d: arguments dict
        :type d: :class:`dict`
        """
        return dRRT(d['num_landmarks'], d['prm_num_landmarks'], d['prm_k'], FT(d['bounding_margin_width_factor']), None, None, None)

    def get_graph(self):
        """
        Return a graph (if applicable).
        Can be overridded by solvers.

        :return: graph whose vertices are Point_2 or Point_d
        :rtype: :class:`networkx.Graph` or :class:`None`
        """
        return self.tensor_roadmap.T

    def load_scene(self, scene):
        """
        Load a scene into the solver.
        Also build the tensor roadmap.

        :param scene: scene to load
        :type scene: :class:`~discopygal.solver.Scene`
        """
        super().load_scene(scene)

        self.sampler.set_scene(scene, self._bounding_box)

        # Generate a PRM for each robot seperatly
        roadmaps = {}
        for i, robot in enumerate(self.scene.robots):
            if self.verbose:
                print('generating PRM #{}...'.format(i+1), file=self.writer)
            roadmaps[robot] = build_probabilistic_roadmap(
                self.scene, robot,
                self.prm_num_landmarks, self.prm_k,
                self.prm_nearest_neighbors, self.sampler)

        # Construct the tensor roadmap
        self.tensor_roadmap = TensorRoadmap(roadmaps, self.nearest_neighbors, self.metric)

        # Convert the start and end endpoints to Point_d
        self.start_points = []
        self.end_points = []
        for robot in self.tensor_roadmap.robots:
            if type(robot) is RobotRod:
                self.start_points.append(robot.start[0])
                self.end_points.append(robot.end[0])
            else:
                self.start_points.append(robot.start)
                self.end_points.append(robot.end)
        self.start_points = conversions.Point_2_list_to_Point_d(self.start_points)
        self.end_points = conversions.Point_2_list_to_Point_d(self.end_points)

        # Add the start vertex to the RRT
        self.tensor_roadmap.add_tensor_vertex(self.start_points)

        # Add the given amount of landmarks to the RRT
        # EXPAND(T)
        cnt = 0
        while cnt <= self.num_landmarks:
            # q_rand <-- RANDOM_SAMPLE()
            q_rand = []
            for _ in self.tensor_roadmap.robots:
                q_rand.append(self.sampler.sample())
            q_rand = conversions.Point_2_list_to_Point_d(q_rand)

            # q_near <-- NEAREST_NEIGHBOR(T, q_rand)
            q_near = self.tensor_roadmap.nearest_tensor_vertex(q_rand)

            # q_new <-- O_D(q_near, q_rand)
            # if q_new \not\in R then
            #       T.add_vertex(q_new)
            #       T.add_edge(q_near, q_new)
            # NOTE: in original paper there is no treatment for when the "oracle"
            #       doesn't return a valid edge, here we just ignore and try again
            added = self.tensor_roadmap.find_best_edge(q_near, q_rand)

            if added:
                cnt += 1
                if cnt % 100 == 0 and self.verbose:
                    print('added', cnt, 'landmarks in dRRT', file=self.writer)

        # Finally try to connect to the end point
        self.tensor_roadmap.add_tensor_vertex(self.end_points)
        neighbors = self.tensor_roadmap.nearest_neighbors.k_nearest(self.end_points, self.prm_k+1)
        for neighbor in neighbors:
            if neighbor != self.end_points:
                self.tensor_roadmap.try_connecting(neighbor, self.end_points)

    def solve(self):
        """
        Based on the start and end locations of each robot, solve the scene
        (i.e. return paths for all the robots)

        :return: path collection of motion planning
        :rtype:  :class:`~discopygal.solvers.PathCollection`
        """
        if not nx.algorithms.has_path(self.tensor_roadmap.get_tensor_subgraph(), self.start_points, self.end_points):
            if self.verbose:
                print('no path found...', file=self.writer)
            return PathCollection()

        # Convert from a sequence of Point_d points to PathCollection
        tensor_path = nx.algorithms.shortest_path(self.tensor_roadmap.get_tensor_subgraph(),
            self.start_points, self.end_points, weight='weight')
        path_collection = PathCollection()
        for i, robot in enumerate(self.tensor_roadmap.robots):
            points = []
            for point in tensor_path:
                points.append(PathPoint(Point_2(point[2*i], point[2*i+1])))
            path = Path(points)
            path_collection.add_robot_path(robot, path)

        if self.verbose:
            print('successfully found a path...', file=self.writer)

        return path_collection